#
#   Copyright 2013 Free Software Foundation, Inc.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Various routines to do useful things with the spooler
# Note that virtually everything requires $main::USERPATH to be set to the User Path where binaries are stuffed

# Operations to create / modify / delete printers

package editptr;
use Socket;
use strict;

our $Porttype = {Parallel => sub { parallel->new; },
                 USB      => sub { usb->new; },
                 Serial   => sub { serial->new; },
                 Network  => sub { 0; }
};
our $Nettype =  {LPD      => sub { lpdnet->new; },
                 Telnet   => sub { telnet->new; },
                 FTP      => sub { ftp->new; },
                 HPNPF    => sub { xtlhp->new; }
};
our $Emultype = {plain => sub { printertype_plain->new; },
                 IBM   => sub { printertype_ibm->new; },
                 Epson => sub { printertype_epson->new; },
                 PCL   => sub { printertype_pcl->new; },
                 PS    => sub { printertype_ps->new; },
                 'PCL/PS' => sub { printertype_pclps->new; },
                 PJL   => sub { printertype_pjl->new; }
};

# Get host name or IP

sub gethostorip {
    my $Env = shift;
    my $ptrname = shift;
    for  (;;)  {
        my $h = $Env->askstring("Host name or IP for $ptrname", "", "Please give the printer host name or IP address to reach $ptrname");
        return undef unless defined $h;
        return $h if defined inet_aton($h);
        print "$h is an invalid host name, please try again\n";
    }
}

# Get printer name in acceptable form, let the guy abort with ESC

sub getptrname {
    my $Env = shift;
    my $ptrlist = $Env->printerlist;

    for  (;;)  {
        my $ptrname = $Env->askstring("Name for printer", "", "Please give a suitable name for the printer");
        return undef unless defined $ptrname;
        my $oka = $ptrlist->okadd($ptrname);
        return $ptrname if $oka > 0;
        if  ($oka < 0)  {
            print "Sorry $ptrname isn't a suitable name, should be a string of letters and possible digits\n";
            redo;
        }
        print "Sorry $ptrname clashes with an existing printer name\n";
    }
}

sub askform ($$$$) {
    my $Env = shift;
    my $prompt = shift;
    my $dflt = shift;
    my $help = shift;
    for  (;;)  {
        my $newft;
        if  ($Env->askyorn("Do you want to use a standard form name", 1, "Do you want a standard name such as 'a4', 'letter' for the\n$prompt"))  {
            $newft = $Env->askopt("Form type", [ "a4", "11x7", "letter", "legal", "ledger", "note"], "Press space to get next selection", "a4");
            redo unless defined $newft;
            return $newft;
        }
        $newft = $Env->askstring($prompt, $dflt, $help);
        return undef unless defined $newft;
        return $newft if $newft =~ /^\w[\w\.-]*$/;
        print "$newft does not look like a valid form type\n";
    }
}

# Create .device file

sub write_device ($$) {
    my $Env = shift;
    my $ptr = shift;
    my $ptrname = $ptr->name;
    my $pt = $ptr->devtype;
    my $filename = "$main::SPOOLPT/$ptrname/.device";
    open(DVF, ">$filename") or die "Cannot create $filename";
    my @tbits = localtime();
    my $timestring = sprintf "%.2d/%.2d/%.4d at %.2d:%.2d:%.2d", $tbits[3], $tbits[4]+1, $tbits[5], $tbits[2], $tbits[1], $tbits[0];
    my $porttype = $pt->typedescr;
    print DVF <<EOT;
# Device file for $ptrname created $timestring
# Porttype: $porttype
#
# This file contains parameters for the above interface
# It is read in ahead of any "setup file" such as "default"
# and should contain interface-only features
#
# Please do not edit this file directly without changing
# "Porttype" above to "custom" or it may get overwritten
#
EOT
    $pt->output(\*DVF);
     my $nwcmd = $pt->netcmd;
     if  (defined $nwcmd)  {
         print DVF "# The following command is used to transmit data to the interface\n";
         print DVF "network=",join(' ', @$nwcmd), "\n";
     }
     close DVF;
     chown $main::Daemuid, $main::Daemgid, $filename;
}

sub write_default ($$) {
    my $Env = shift;
    my $ptr = shift;
    my $ptrname = $ptr->name;
    my $et = $ptr->ptremul;
    my $filename = "$main::SPOOLPT/$ptrname/default";
    open(DFF, ">$filename") or die "Cannot create $filename";
    my @tbits = localtime();
    my $timestring = sprintf "%.2d/%.2d/%.4d at %.2d:%.2d:%.2d", $tbits[3], $tbits[4]+1, $tbits[5], $tbits[2], $tbits[1], $tbits[0];
    my $ptrtype = $et->typedescr;
    print DFF <<EOT;
# Setup file for $ptrname created $timestring
# Ptrtype: $ptrtype
#
# This file contains parameters for the above emulation
# This file "default" is read in unless a file is found of
# the same name as the form type.
# Form types can be refined by "suffixes" .a .b or such
# to give alternative handlings
#
# Please do not edit this file directly without changing
# "Ptrtype" above to "custom" or it may get overwritten
#
EOT
    my $params = $et->{PARAMS};
    my $p = $ptr->printer_type;
    print DFF <<EOT if length($p) > 0;
# Reported printer model
# Ptrname: $p
EOT
    print DFF <<EOT if $params->{gsforps}->{VALUE};
# Using ghostscript
EOT
    $p = $params->{papersize}->{VALUE};
    print DFF <<EOT if length($p) > 0;
# Paper: $p
EOT
    $p = $params->{colour}->{VALUE};
    if (defined $p)  {
        my $v = $p? "Yes": "No";
        print DFF <<EOT;
# Colour: $v
EOT
       $v = $params->{colourdef}->{VALUE}? "Yes": "No";
        print DFF <<EOT;
# Default colour: $v
EOT
    }
    print DFF "\n";
    $et->output(\*DFF);
    $et->generate_setup(\*DFF);
    close DFF;
    chown $main::Daemuid, $main::Daemgid, $filename;
}

# Set up printer definition

sub setup_printer {
    my $Env = shift;
    my $ptr = shift;
    my $ptrname = $ptr->name;
    # First create printer directory
    filerouts::rmkdir("$main::SPOOLPT/$ptrname", 0);
    write_device($Env, $ptr);
    write_default($Env, $ptr);
    $Env->printerlist->add($ptr);
    print "\n\nCompleted creation of $ptrname\n";
}

# Mechanics of setting up clone

sub setup_clone {
    my $Env = shift;
    my $clptr = shift;
    my $ptrname = shift;
    my $ptrlist = $Env->printerlist;
    my $clonedptr = $ptrlist->getptr($clptr);
    symlink $clptr, "$main::SPOOLPT/$ptrname";
    my $nptr = printer->new;
    $nptr->name($ptrname);
    $nptr->custom($clonedptr->custom);
    $nptr->cloneof($clptr);
    $nptr->descr($clonedptr->descr);
    $nptr->printer_type($clonedptr->printer_type);
    $nptr->devtype($clonedptr->devtype);
    $nptr->ptremul($clonedptr->ptremul);
    $ptrlist->add($nptr);
    print "\n\nCompleted creation of clone $ptrname of $clptr\n";
}

sub delete_ptr ($$) {
    my $Env = shift;
    my $ptr = shift;
    my $ptrname = $ptr->name;
    my $path = "$main::SPOOLPT/$ptrname";
    if  ($ptr->isclone)  {
        unlink $path;
    }
    else  {
        system("rm -rf $path");
    }
    $Env->printerlist->del($ptr);
}

sub declone ($$) {
    my $Env = shift;
    my $ptr = shift;
    my $ptrname = $ptr->name;
    my $path = "$main::SPOOLPT/$ptrname";
    unless  (-l $path)  {
        print "Confused by $ptrname, thought it was a clone\n";
        return;
    }
    unlink $path;
    my $clof = $ptr->isclone;
    system("cd $main::SPOOLPT;cp -r -p $clof $ptrname");
    $ptr->cloneof(undef);
}

# See if the guy wants it set up as a clone and return 1 if so, doing the business
# Return 0 if not a clone
# Return under if aborted

sub getasclone {
    my $Env = shift;
    my $ptrname = shift;
    my $ptrlist = $Env->printerlist;
    my $cloneable = $ptrlist->getcloneable;

    # Nothing cloneable, return nothing
    return 0 if $#$cloneable < 0;

    # If only one cloneable, just ask about that

    my $clptr = $cloneable->[0];
    if  ($#$cloneable == 0)  {
        return  0  unless  $Env->askyorn("Do you want $ptrname as a clone of $clptr", 0, "askcclone");
    }
    else  {
        return  0  unless $Env->askyorn("Do you want $ptrname as a clone of another printer", 0, "askcclone");
        $clptr = $Env->askopt("Which printer to clone", $cloneable, "Please select which printer to clone");
        return  undef  unless  defined($clptr);
    }
    setup_clone($Env, $clptr, $ptrname);
    1;
}

# Try to connect to a port

sub tryconnect {
    my $host = shift;
    my $port = shift;
    my $proto = getprotobyname('tcp');
    my $sin = sockaddr_in($port, inet_aton($host));
    socket(SOCKFD, PF_INET, SOCK_STREAM, $proto);
    my $ret = connect(SOCKFD, $sin);
    close SOCKFD;
    $ret;
}

# Get printer name from SNMP if possible

sub getsnmptype {
    my $ipaddr = shift;
    my $getsnmp = "$main::USERPATH/getsnmp";
    return undef unless -x $getsnmp;
    my $nm = `$getsnmp -N -h $ipaddr 1.3 2>/dev/null`;
    return undef unless length($nm) > 0;
    chop $nm;
    $nm;
}

sub getnettype {
    my $Env = shift;
    my $ptr = shift;
    my $ptrname = $ptr->name;
    my $host;
    my $mfrdescr;
    my @types;
    my $havelpd;
    if  ($Env->askyorn("Can I probe printer", 1, "isconn"))  {
        $host = gethostorip($Env, $ptrname);
        return undef unless defined $host;
        if (tryconnect($host, 515))  {
            $havelpd = "LPD";
            push @types, "LPD";
        }
        push @types, "FTP" if tryconnect($host, 21);
        if  (tryconnect($host, 9100))  {
            push @types, "Telnet";
            $mfrdescr = getsnmptype($host);
            push @types, "HPNPF" if length($mfrdescr) > 0;
        }
    }
    else  {
        @types = sort keys %$Nettype;
        $havelpd = "LPD";
    }
    my $st = $Env->askopt("Which type of protocol", \@types, "conntype", $havelpd);
    return undef unless defined $st;
    my $pirout = $Nettype->{$st};
    my $ret = &$pirout;

    # Set mfr descr and host/IP if we've got them

    $ptr->printer_type($mfrdescr) if $mfrdescr;
    $ptr->insdev($host) if $host;
    $ret;
}

sub getporttype {
    my $Env = shift;
    my $ptr = shift;
    my $ptrname = $ptr->name;
    my @porttypes = sort keys %$Porttype;
    my $spt = $Env->askopt("Which basic type of port for $ptrname", \@porttypes, "porttype", "Network");
    return undef unless defined($spt);
    my $pts = &{$Porttype->{$spt}}; # Sets to zero for network
    $pts = getnettype($Env, $ptr) unless $pts;
    $pts;
}

sub getemultype {
    my $Env = shift;
    my $ptr = shift;
    my $ptrname = $ptr->name;
    my @etypes = sort keys %$Emultype;
    my $set = $Env->askopt("Which emulation for $ptrname", \@etypes, "emultype", "PCL/PS");
    return undef unless defined $set;
    my $ets = &{$Emultype->{$set}};
    $ets;
}

sub editdevopts {
    my $Env = shift;
    my $ptr = shift;
    my $ptrname = $ptr->name;
    my $pt = $ptr->devtype;
    for  (;;)  {
        $Env->clear;
        print <<EOT;
Device parameters for $ptrname are as follows:

EOT
       my $pars = $pt->display();
        outformat::multicol(\*STDOUT, $pars);
        return unless $Env->askyorn("Change any of those", 0, "devparam");
        $pt->ask($Env);
    }
}

sub editspoolopts {
    my $Env = shift;
    my $ptr = shift;
    my $ptrname = $ptr->name;
    my $et = $ptr->ptremul;
    for  (;;)  {
        $Env->clear;
        print <<EOT;
Spooling parameters for $ptrname are as follows:

EOT
      my $pars = $et->display();
       outformat::multicol(\*STDOUT, $pars);
       return unless $Env->askyorn("Change any of those", 0, "spoolparam");
       $et->ask($Env);
    }
}

sub getasnew {
    my $Env = shift;
    my $ptrname = shift;
    my $ptr = printer->new;
    $ptr->name($ptrname);
    my $pt = getporttype($Env, $ptr);
    return undef unless defined $pt;
    $ptr->devtype($pt);
    my $et = getemultype($Env, $ptr);
    return undef unless defined $et;
    $ptr->ptremul($et);
    editdevopts($Env, $ptr);
    editspoolopts($Env, $ptr);
    return 0 unless $Env->askyorn("OK to create definition for $ptrname", 1, "Just checking ready to install printer definition");
    setup_printer($Env, $ptr);
    1;
}

sub askdevice ($$$) {
    my $Env = shift;
    my $ptrname = shift;
    my $type = shift;
    for  (;;)  {
        my $d = $Env->askstring("Device name (excluding /dev)", "", "Please give the name of the $type device for $ptrname");
        return undef unless defined $d;
        return $d if -c "/dev/$d";
        print "/dev/$d is an invalid device name, please try again\n";
    }
}

# Get physical device (i.e. serial/parallel/USB)

sub getphysdevice ($$) {
    my $Env = shift;
    my $ptr = shift;
    # Might have been a previous device, offer if if so, otherwise prompt
    # (zap it if it is duplicated)
    my $dev = $ptr->insdev;
    my %instdev;
    map { $instdev{$_} = 1; } @{$Env->printerlist->getdevices};
    $dev = "" if length($dev) > 0 && defined $instdev{$dev};
    $dev = "" unless -c "/dev/$dev";
    unless (length($dev) > 0  &&  $Env->askyorn("OK to use /dev/$dev again", 1, "reusedev"))  {
        $dev = askdevice($Env, $ptr->name, $ptr->devtype->typedescr);
        return 0 unless defined $dev;
    }
    # Check accessible by user
    my $fdev = "/dev/$dev";
    my @sbits = stat $fdev;
    my $mbits = $sbits[2] & 07777;
    my $fuser = $sbits[4];
    my $fgroup = $sbits[5];
    if  ($sbits[4] == $main::Daemuid)  {
        chmod $mbits | 0200, $fdev;
    }
    elsif ($Env->askyorn("$fdev is not owned by system user - fix", 1, "notowned"))  {
        chown $main::Daemuid, $main::Daemgid, $fdev;
        chmod $mbits | 0200, $fdev;
    }
    elsif  ($sbits[5] == $main::Daemgid)  {
        chmod $mbits | 0020, $fdev;
    }
    elsif  ($Env->askyorn("$fdev is not group-owned by system group - fix", 1, "notgroup"))  {
        chown $sbits[4], $main::Daemgid, $fdev;
    }
    else  {
        chmod $mbits | 0002, $fdev;
    }
    $ptr->insdev($dev);
    $ptr->insnet(0);
    1;
}

# Get description of printer

sub getdescr ($$) {
    my $Env = shift;
    my $ptr = shift;
    my $descr = $ptr->descr;
    $descr = $ptr->printer_type if length($descr) == 0;
    $descr = $Env->askstring("Description of printer", $descr, "ptrdescr");
    return 9 unless defined $descr;
    $ptr->descr($descr);
    1;
}

sub install_ptr ($$) {
    my $Env = shift;
    my $ptrname = shift;
    my $ptrlist = $Env->printerlist;
    my $ptr = $ptrlist->getptr($ptrname);
    return unless defined $ptr;         # Huh???
    my $pt = $ptr->devtype;
    my $nc = length($pt->{NETDEV}) > 0;
    # We might have a record of the device from a probe or previous installation
    # However in the case of non-network devices we need to squash that if something
    # else is installed to that device
    if  ($nc)  {
        my $host = $ptr->insdev;
        unless  (length($host) > 0  &&  $Env->askyorn("Install using host address $host", 1, "ehost"))  {
            $host = gethostorip($Env, $ptrname);
            return unless defined $host;
        }
        $ptr->insdev($host);
        $ptr->insnet(1);
    }
    else  {
        return unless getphysdevice($Env, $ptr);
    }
    my $formt = $ptr->insform || $ptr->ptremul->{PARAMS}->{papersize}->{VALUE} || $Env->{STDFORM};
    my $newf = askform($Env, "Form type for $ptrname", $formt, "Please give the initial form type to be installed with $ptrname");
    return unless $newf;
    $ptr->insform($newf);
    # Now get description, we might have a fossil one from before if not grab type if avail
    return unless getdescr($Env, $ptr);
    if (spool_ops::install_printer($ptr))  {
        $ptr->installed(1);
        ptrins_cupspy::cupspy_install($Env, $ptr);
        print "Completed installation of printer $ptrname\n";
        spool_ops::restart_printer($ptr) if $Env->askyorn("Shall I start $ptrname now", 0, "Do you want to start the newly-installed printer $ptrname");
    }
}

sub deinstall_ptr ($$) {
    my $Env = shift;
    my $ptr = shift;
    my $ptrname = $ptr->name;
    if (spool_ops::deinstall_printer($ptr))  {
        $ptr->installed(0);
        ptrins_cupspy::cupspy_deinstall($Env, $ptr);
        print "De-installed $ptrname OK\n";
        return 1;
    }
    else  {
        print "OOPS could not de-install $ptrname\n";
        return 0;
    }
}

sub create_printer ($) {
    my $Env = shift;
    # Ask printer name, giving the guy an opportunity to escape with ESC
    # See if he wants it as a clone, then as a new one
    my $ptrname = getptrname($Env);
    return unless defined($ptrname);
    my $ret = getasclone($Env, $ptrname);
    return unless defined($ret);
    $ret = getasnew($Env, $ptrname) unless $ret > 0;
    return unless $ret > 0;
    install_ptr($Env, $ptrname) if $Env->isrunning && $Env->askyorn("Do you want to install $ptrname now", 0, "installptr");
}

sub modify_printer {
    my $Env = shift;
    my $Printerlist = $Env->printerlist;
    my $Printernames = $Printerlist->getptrlist;
    my $dpl = $Printerlist->display;
    my ($installed, $uninstalled) = @$dpl;
    if ($#$installed >= 0)  {
        print "\nThe following printers are installed\n\n";
        outformat::multicol(\*STDOUT, $installed);;
    }
    if ($#$uninstalled >= 0)  {
        print "\nThe following printers are defined but not installed\n\n";
        outformat::multicol(\*STDOUT, $uninstalled);
    }
    my $ptrname = $Printernames->[0];
    if  ($#$Printernames > 0)  {
        $ptrname = $Env->askopt("Which printer would you like to change", $Printernames, "Please select the printer you want to edit - tab or space to select");
        return unless defined $ptrname;
    }
    else  {
        print "Selecting $ptrname\n";
    }
    my $ptr = $Printerlist->getptr($ptrname);
    if  ($ptr->installed)  {
        unless ($Env->isrunning)  {
            print "Sorry cannot do anything with $ptrname as spooler is not running\n";
            return;
        }
        if (spool_ops::isrunning_ptr($ptr))  {
            return  unless  $Env->askyorn("$ptrname is running, do you want to halt", 0,
                    "The printer $ptrname is currently enabled.\nYou will need to halt it first if you want to make changes");
            spool_ops::stop_printer($ptr);
        }
        return unless $Env->askyorn("OK to de-install $ptrname", 0, "Please confirm that you want to de-install $ptrname");
        return unless deinstall_ptr($Env, $ptr);
    }
    if (!$Printerlist->okdel($ptr))  {
        print "(Can't delete $ptrname because it's cloned)\n";
    }
    elsif  ($Env->askyorn("Do you want to delete $ptrname", 0, "Please indicate if you want to delete $ptrname completely"))  {
        delete_ptr($Env, $ptr);
        return;
    }
    my $isc = $ptr->isclone;
    declone($Env, $ptr) if  $isc  &&  $Env->askyorn("$ptrname is a clone, de-clone", 0, "$ptrname is currently a clone of $isc.\nDo you want to turn $ptrname to a printer in its own right");
    if ($ptr->custom)  {
       print "Interface is custom, not trying to edit it\n";
    }
    elsif ($Env->askyorn("Edit the interface", 0, "Do you want to edit the interface parameters"))  {
        editdevopts($Env, $ptr);
        write_device($Env, $ptr);
    }
    if ($ptr->devtype->typedescr eq "Custom")  {
        print "Emulation is custom, not trying to edit it\n";
    }
    elsif ($Env->askyorn("Edit the emulation parameters", 0, "Do you want to edit the emulation parameters"))  {
        editspoolopts($Env, $ptr);
        write_default($Env, $ptr);
    }
    return unless $Env->isrunning  &&  $Env->askyorn("Do you want to install $ptrname", 0, "Do you now want to install the edited $ptrname to the system");
    install_ptr($Env, $ptrname);
}

1;
